{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/gdo.js"],"names":["GDO","this","reset","_groups","_elements","_element","push","nodes","forEach","element","name","DAG","TAG","GRP","BEFORE","AFTER","group","takeField","field","_typeof","Array","tag","before","after","concat","idx","_this","indexOf","Error","undefined","length","insertDAG","list","order","elements","_order2","edges","Object","keys","_toposort2","array","reverse","filter","match","module","exports"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  GDO -- Group- and Dependency-based Ordering\n**  Copyright (c) 2015-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport toposort from \"toposort\"\n\n/*  the API class  */\nclass GDO {\n    constructor () {\n        this.reset()\n    }\n\n    /*  reset the instance  */\n    reset () {\n        this._groups   = []\n        this._elements = []\n    }\n\n    /*  configure all groups  */\n    groups (groups) {\n        this._groups = groups\n    }\n\n    /*  configure one element  */\n    element (element) {\n        this._elements.push(element)\n    }\n\n    /*  topologically order the elements by taking account\n        of tags, groups and dependencies  */\n    order () {\n        /*  determine all graph nodes  */\n        let nodes = {}\n        this._elements.forEach((element) => {\n            nodes[element.name] = true\n        })\n\n        /*  internal helper data structures  */\n        let DAG    = {}\n        let TAG    = {}\n        let GRP    = {}\n        let BEFORE = {}\n        let AFTER  = {}\n\n        /*  pre-fill all groups with sentinel elements to ensure that\n            a group dependency always has at least one element it can be\n            expanded to  */\n        this._groups.forEach((group) => {\n            GRP[group] = [ `@@@${group}` ]\n            nodes[`@@@${group}`] = true\n        })\n\n        /*  helper function for taking zero or more strings out of a field  */\n        let takeField = (field) => {\n            if (typeof field === \"object\" && field instanceof Array)\n                return field\n            else if (typeof field === \"string\")\n                return [ field ]\n            else\n                return []\n        }\n\n        /*  pass 1: iterate over all elements and pre-process information  */\n        this._elements.forEach((element) => {\n            /*  take information of element  */\n            let name   = element.name\n            let tag    = takeField(element.tag)\n            let before = takeField(element.before)\n            let after  = takeField(element.after)\n            let group  = element.group\n\n            /*  remember (a mutable copy of) after/before information  */\n            BEFORE[name] = [].concat(before)\n            AFTER[name]  = [].concat(after)\n\n            /*  remember mapping of tag to element  */\n            tag.forEach((tag) => {\n                let idx = this._groups.indexOf(tag)\n                if (idx > -1)\n                    throw new Error(`invalid tag (cannot be same name as group): \"${tag}\"`)\n                if (TAG[tag] === undefined)\n                    TAG[tag] = []\n                TAG[tag].push(name)\n            })\n\n            /*  remember group of module  */\n            if (group !== undefined) {\n                let idx = this._groups.indexOf(group)\n                if (idx === -1)\n                    throw new Error(`unknown group: \"${group}\"`)\n                GRP[group].push(name)\n                if (idx < this._groups.length - 1)\n                    BEFORE[name].push(this._groups[idx + 1])\n                if (idx > 0)\n                    AFTER[name].push(this._groups[idx - 1])\n            }\n        })\n\n        /*  helper function: insert edge into DAG  */\n        let insertDAG = (list, order) => {\n            list.forEach((element) => {\n                let elements\n                if (TAG[element] !== undefined)\n                    elements = TAG[element]\n                else if (GRP[element] !== undefined)\n                    elements = GRP[element]\n                else\n                    elements = [ element ]\n                elements.forEach((element) => {\n                    let [ before, after ] = order(element)\n                    if (nodes[before] === undefined)\n                        throw new Error(`unknown element: ${before}`)\n                    if (nodes[after] === undefined)\n                        throw new Error(`unknown element: ${after}`)\n                    if (DAG[before] === undefined)\n                        DAG[before] = {}\n                    DAG[before][after] = true\n                })\n            })\n        }\n\n        /*  pass 2: iterate over all elements and process \"after\" and \"before\" information  */\n        this._elements.forEach((element) => {\n            /*  take information of module  */\n            let name   = element.name\n            let before = BEFORE[name]\n            let after  = AFTER[name]\n\n            /*  insert all \"after\" dependencies into DAG\n                (as standard \"after\" dependencies)  */\n            insertDAG(after,  (element) => [ name, element ])\n\n            /*  insert all \"before\" dependencies into DAG\n                (as inverse \"after\" dependencies)  */\n            insertDAG(before, (element) => [ element, name ])\n        })\n\n        /*  determine resulting graph edges  */\n        let edges = []\n        Object.keys(DAG).forEach((before) => {\n            Object.keys(DAG[before]).forEach((after) => {\n                edges.push([ before, after ])\n            })\n        })\n\n        /*  perform a topological sorting of the graph  */\n        let elements = toposort.array(Object.keys(nodes), edges).reverse()\n\n        /*  remove group sentinel values again  */\n        elements = elements.filter((element) => !element.match(/^@@@.+/))\n\n        /*  return the final ordered list of elements  */\n        return elements\n    }\n}\n\nmodule.exports = GDO\n\n"]}