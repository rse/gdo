{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/gdo.js"],"names":["_toposort","require","GDO","this","reset","_groups","_elements","_element","push","nodes","forEach","element","name","DAG","TAG","GRP","BEFORE","AFTER","group","takeField","field","_typeof","Array","tag","before","after","concat","idx","_this","indexOf","Error","undefined","length","insertDAG","list","order","elements","_order2","edges","Object","keys","_toposort2","array","reverse","filter","match","module","exports"],"mappings":"AAAA;4jCCwBAA,UAAAC,QAAA,yDAGMC,IAAA,WACF,QAAAA,6BACIC,KAAKC,6DAKLD,KAAKE,WACLF,KAAKG,4CAIDD,GACJF,KAAKE,QAAUA,kCAIVE,GACLJ,KAAKG,UAAUE,KAAKD,8CAOhBE,IACJN,MAAKG,UAAUI,QAAQ,SAACC,GACpBF,EAAME,EAAQC,OAAQ,GAJrB,IAQDC,MACAC,KACAC,KACAC,KACAC,IAZCd,MAiBAE,QAAQK,QAAQ,SAACQ,GAClBH,EAAIG,IAAS,MAAQA,GACrBT,EAAA,MAAYS,IAAW,GAnBtB,IAuBDC,GAAY,SAACC,GACb,MAAqB,YAAV,mBAAAA,GAAA,YAAAC,QAAAD,KAAsBA,YAAiBE,OACvCF,EACe,gBAAVA,IACHA,MA3BZjB,MAiCAG,UAAUI,QAAQ,SAACC,GAEpB,GAAIC,GAASD,EAAQC,KACjBW,EAASJ,EAAUR,EAAQY,KAC3BC,EAASL,EAAUR,EAAQa,QAC3BC,EAASN,EAAUR,EAAQc,OAC3BP,EAASP,EAAQO,KANW,IAAAF,EASzBJ,MAAWc,OAAOF,GACzBP,EAAML,MAAYc,OAAOD,GAVOF,EAa5Bb,QAAQ,SAACa,GACT,GAAII,GAAMC,EAAKvB,QAAQwB,QAAQN,EAC/B,IAAII,EAAM,GACN,KAAM,IAAIG,OAAJ,gDAA0DP,EAAA,IACnDQ,UAAbjB,EAAIS,KACJT,EAAIS,OACRT,EAAIS,GAAKf,KAAKI,KAIJmB,SAAVb,EAAqB,CACrB,GAAIS,GAAMC,EAAKvB,QAAQwB,QAAQX,EAC/B,IAAY,KAARS,EACA,KAAM,IAAIG,OAAJ,mBAA6BZ,EAAA,IACvCH,GAAIG,GAAOV,KAAKI,GACZe,EAAMC,EAAKvB,QAAQ2B,OAAS,GAC5BhB,EAAOJ,GAAMJ,KAAKoB,EAAKvB,QAAQsB,EAAM,IACrCA,EAAM,GACNV,EAAML,GAAMJ,KAAKoB,EAAKvB,QAAQsB,EAAM,MAhE3C,IAqEDM,GAAY,SAACC,EAAMC,GACnBD,EAAKxB,QAAQ,SAACC,GACV,GAAIyB,GAAAL,MAEAK,GADiBL,SAAjBjB,EAAIH,GACOG,EAAIH,GACOoB,SAAjBhB,EAAIJ,GACEI,EAAIJ,IAEFA,GACjByB,EAAS1B,QAAQ,SAACC,SACUwB,EAAMxB,yBAAxBa,EAAAa,EAAA,GAAQZ,EAAAY,EAAA,EACd,IAAsBN,SAAlBtB,EAAMe,GACN,KAAM,IAAIM,OAAJ,oBAA8BN,EACxC,IAAqBO,SAAjBtB,EAAMgB,GACN,KAAM,IAAIK,OAAJ,oBAA8BL,EACpBM,UAAhBlB,EAAIW,KACJX,EAAIW,OACRX,EAAIW,GAAQC,IAAS,MAtF5BtB,MA4FAG,UAAUI,QAAQ,SAACC,GAEpB,GAAIC,GAASD,EAAQC,KACjBY,EAASR,EAAOJ,GAChBa,EAASR,EAAML,EAJaqB,GAQtBR,EAAQ,SAACd,UAAcC,EAAMD,KARPsB,EAYtBT,EAAQ,SAACb,UAAcA,EAASC,MAxGzC,IA4GD0B,KACJC,QAAOC,KAAK3B,GAAKH,QAAQ,SAACc,GACtBe,OAAOC,KAAK3B,EAAIW,IAASd,QAAQ,SAACe,GAC9Ba,EAAM9B,MAAOgB,EAAQC,OA/GxB,IAoHDW,GAAWK,WAAAA,WAASC,MAAMH,OAAOC,KAAK/B,GAAQ6B,GAAOK,SApHpD,OAAAP,GAuHMA,EAASQ,OAAO,SAACjC,UAAaA,EAAQkC,MAAM,oBAO/DC,QAAOC,QAAU7C","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  GDO -- Group- and Dependency-based Ordering\n**  Copyright (c) 2015-2016 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport toposort from \"toposort\"\n\n/*  the API class  */\nclass GDO {\n    constructor () {\n        this.reset()\n    }\n\n    /*  reset the instance  */\n    reset () {\n        this._groups   = []\n        this._elements = []\n    }\n\n    /*  configure all groups  */\n    groups (groups) {\n        this._groups = groups\n    }\n\n    /*  configure one element  */\n    element (element) {\n        this._elements.push(element)\n    }\n\n    /*  topologically order the elements by taking account\n        of tags, groups and dependencies  */\n    order () {\n        /*  determine all graph nodes  */\n        let nodes = {}\n        this._elements.forEach((element) => {\n            nodes[element.name] = true\n        })\n\n        /*  internal helper data structures  */\n        let DAG    = {}\n        let TAG    = {}\n        let GRP    = {}\n        let BEFORE = {}\n        let AFTER  = {}\n\n        /*  pre-fill all groups with sentinel elements to ensure that\n            a group dependency always has at least one element it can be\n            expanded to  */\n        this._groups.forEach((group) => {\n            GRP[group] = [ `@@@${group}` ]\n            nodes[`@@@${group}`] = true\n        })\n\n        /*  helper function for taking zero or more strings out of a field  */\n        let takeField = (field) => {\n            if (typeof field === \"object\" && field instanceof Array)\n                return field\n            else if (typeof field === \"string\")\n                return [ field ]\n            else\n                return []\n        }\n\n        /*  pass 1: iterate over all elements and pre-process information  */\n        this._elements.forEach((element) => {\n            /*  take information of element  */\n            let name   = element.name\n            let tag    = takeField(element.tag)\n            let before = takeField(element.before)\n            let after  = takeField(element.after)\n            let group  = element.group\n\n            /*  remember (a mutable copy of) after/before information  */\n            BEFORE[name] = [].concat(before)\n            AFTER[name]  = [].concat(after)\n\n            /*  remember mapping of tag to element  */\n            tag.forEach((tag) => {\n                let idx = this._groups.indexOf(tag)\n                if (idx > -1)\n                    throw new Error(`invalid tag (cannot be same name as group): \"${tag}\"`)\n                if (TAG[tag] === undefined)\n                    TAG[tag] = []\n                TAG[tag].push(name)\n            })\n\n            /*  remember group of module  */\n            if (group !== undefined) {\n                let idx = this._groups.indexOf(group)\n                if (idx === -1)\n                    throw new Error(`unknown group: \"${group}\"`)\n                GRP[group].push(name)\n                if (idx < this._groups.length - 1)\n                    BEFORE[name].push(this._groups[idx + 1])\n                if (idx > 0)\n                    AFTER[name].push(this._groups[idx - 1])\n            }\n        })\n\n        /*  helper function: insert edge into DAG  */\n        let insertDAG = (list, order) => {\n            list.forEach((element) => {\n                let elements\n                if (TAG[element] !== undefined)\n                    elements = TAG[element]\n                else if (GRP[element] !== undefined)\n                    elements = GRP[element]\n                else\n                    elements = [ element ]\n                elements.forEach((element) => {\n                    let [ before, after ] = order(element)\n                    if (nodes[before] === undefined)\n                        throw new Error(`unknown element: ${before}`)\n                    if (nodes[after] === undefined)\n                        throw new Error(`unknown element: ${after}`)\n                    if (DAG[before] === undefined)\n                        DAG[before] = {}\n                    DAG[before][after] = true\n                })\n            })\n        }\n\n        /*  pass 2: iterate over all elements and process \"after\" and \"before\" information  */\n        this._elements.forEach((element) => {\n            /*  take information of module  */\n            let name   = element.name\n            let before = BEFORE[name]\n            let after  = AFTER[name]\n\n            /*  insert all \"after\" dependencies into DAG\n                (as standard \"after\" dependencies)  */\n            insertDAG(after,  (element) => [ name, element ])\n\n            /*  insert all \"before\" dependencies into DAG\n                (as inverse \"after\" dependencies)  */\n            insertDAG(before, (element) => [ element, name ])\n        })\n\n        /*  determine resulting graph edges  */\n        let edges = []\n        Object.keys(DAG).forEach((before) => {\n            Object.keys(DAG[before]).forEach((after) => {\n                edges.push([ before, after ])\n            })\n        })\n\n        /*  perform a topological sorting of the graph  */\n        let elements = toposort.array(Object.keys(nodes), edges).reverse()\n\n        /*  remove group sentinel values again  */\n        elements = elements.filter((element) => !element.match(/^@@@.+/))\n\n        /*  return the final ordered list of elements  */\n        return elements\n    }\n}\n\nmodule.exports = GDO\n\n"]}