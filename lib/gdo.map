{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/gdo.js"],"names":["_toposort","require","GDO","_classCallCheck","this","reset","_groups","_elements","groups","element","push","_this","nodes","forEach","name","Error","DAG","TAG","GRP","BEFORE","AFTER","group","takeField","field","_typeof","Array","tag","before","after","concat","indexOf","undefined","idx","length","insertDAG","list","order","elements","via","_order","_order2","_slicedToArray","edges","Object","keys","_toposort2","default","array","filter","match","module","exports"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*\n**  GDO -- Group- and Dependency-based Ordering\n**  Copyright (c) 2015-2017 Ralf S. Engelschall <rse@engelschall.com>\n**\n**  Permission is hereby granted, free of charge, to any person obtaining\n**  a copy of this software and associated documentation files (the\n**  \"Software\"), to deal in the Software without restriction, including\n**  without limitation the rights to use, copy, modify, merge, publish,\n**  distribute, sublicense, and/or sell copies of the Software, and to\n**  permit persons to whom the Software is furnished to do so, subject to\n**  the following conditions:\n**\n**  The above copyright notice and this permission notice shall be included\n**  in all copies or substantial portions of the Software.\n**\n**  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n**  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n**  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n**  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n**  CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n**  TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n**  SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\nimport toposort from \"toposort\"\n\n/*  the API class  */\nclass GDO {\n    constructor () {\n        this.reset()\n    }\n\n    /*  reset the instance  */\n    reset () {\n        this._groups   = []\n        this._elements = []\n    }\n\n    /*  configure all groups  */\n    groups (groups) {\n        this._groups = groups\n    }\n\n    /*  configure one element  */\n    element (element) {\n        this._elements.push(element)\n    }\n\n    /*  topologically order the elements by taking account\n        of tags, groups and dependencies  */\n    order () {\n        /*  determine all graph nodes  */\n        let nodes = {}\n        this._elements.forEach((element) => {\n            if (nodes[element.name])\n                throw new Error(`element named \"${element.name}\" occurs multiple times (has to be unique)`)\n            nodes[element.name] = true\n        })\n\n        /*  internal helper data structures  */\n        let DAG    = {}\n        let TAG    = {}\n        let GRP    = {}\n        let BEFORE = {}\n        let AFTER  = {}\n\n        /*  pre-fill all groups with sentinel elements to ensure that\n            a group dependency always has at least one element it can be\n            expanded to  */\n        this._groups.forEach((group) => {\n            if (GRP[group])\n                throw new Error(`group named \"${group}\" occurs multiple times (has to be unique)`)\n            GRP[group] = [ `@@@${group}` ]\n            nodes[`@@@${group}`] = true\n        })\n\n        /*  helper function for taking zero or more strings out of a field  */\n        let takeField = (field) => {\n            if (typeof field === \"object\" && field instanceof Array)\n                return field\n            else if (typeof field === \"string\")\n                return [ field ]\n            else\n                return []\n        }\n\n        /*  pass 1: iterate over all elements and pre-process information  */\n        this._elements.forEach((element) => {\n            /*  take information of element  */\n            let name   = element.name\n            let tag    = takeField(element.tag)\n            let before = takeField(element.before)\n            let after  = takeField(element.after)\n            let group  = element.group\n\n            /*  remember (a mutable copy of) after/before information  */\n            BEFORE[name] = [].concat(before)\n            AFTER[name]  = [].concat(after)\n\n            /*  remember mapping of tag to element  */\n            tag.forEach((tag) => {\n                if (this._groups.indexOf(tag) > -1)\n                    throw new Error(`element \"${element.name}\" has invalid tag \"${tag}\" ` +\n                        \"(tag cannot have same name as existing group)\")\n                if (TAG[tag] === undefined)\n                    TAG[tag] = []\n                TAG[tag].push(name)\n            })\n\n            /*  remember group of module  */\n            if (group !== undefined) {\n                let idx = this._groups.indexOf(group)\n                if (idx === -1)\n                    throw new Error(`element \"${element.name}\" has invalid group \"${group}\" ` +\n                        \"(group has to be explicitly defined)\")\n                GRP[group].push(name)\n\n                /*  add implicit before/after for elements of intermediate groups  */\n                if (idx < this._groups.length - 1)\n                    BEFORE[name].push(this._groups[idx + 1])\n                if (idx > 0)\n                    AFTER[name].push(this._groups[idx - 1])\n            }\n        })\n\n        /*  helper function: insert edge into DAG  */\n        let insertDAG = (name, list, order) => {\n            list.forEach((element) => {\n                let elements\n                let via\n                if (TAG[element] !== undefined) {\n                    elements = TAG[element]\n                    via = \"tag-based\"\n                }\n                else if (GRP[element] !== undefined) {\n                    elements = GRP[element]\n                    via = \"group-based\"\n                }\n                else {\n                    elements = [ element ]\n                    via = \"direct\"\n                }\n                elements.forEach((element) => {\n                    let [ before, after ] = order(name, element)\n                    if (nodes[before] === undefined)\n                        throw new Error(`element \"${name}\" has invalid ${via} before-reference ` +\n                            `to unknown element \"${before}\"`)\n                    if (nodes[after] === undefined)\n                        throw new Error(`element \"${name}\" has invalid ${via} after-reference ` +\n                            `to unknown element \"${after}\"`)\n                    if (DAG[before] === undefined)\n                        DAG[before] = {}\n                    DAG[before][after] = true\n                })\n            })\n        }\n\n        /*  pass 2: iterate over all elements and process \"after\" and \"before\" information  */\n        this._elements.forEach((element) => {\n            /*  take information of module  */\n            let name   = element.name\n            let before = BEFORE[name]\n            let after  = AFTER[name]\n\n            /*  insert all \"after\" dependencies into DAG\n                (as standard \"after\" dependencies)  */\n            insertDAG(name, after,  (name, element) => [ element, name ])\n\n            /*  insert all \"before\" dependencies into DAG\n                (as inverse \"after\" dependencies)  */\n            insertDAG(name, before, (name, element) => [ name, element ])\n        })\n\n        /*  determine resulting graph edges  */\n        let edges = []\n        Object.keys(DAG).forEach((before) => {\n            Object.keys(DAG[before]).forEach((after) => {\n                edges.push([ before, after ])\n            })\n        })\n\n        /*  perform a topological sorting of the graph  */\n        let elements = toposort.array(Object.keys(nodes), edges)\n\n        /*  remove group sentinel values again  */\n        elements = elements.filter((element) => !element.match(/^@@@.+/))\n\n        /*  return the final ordered list of elements  */\n        return elements\n    }\n}\n\nmodule.exports = GDO\n\n"]}